extern crate clap;
extern crate iron_lib;
extern crate rusoto_core;
extern crate rusoto_credential;
extern crate rusoto_dynamodb;
extern crate rusoto_kms;

use clap::{App, AppSettings, Arg, SubCommand};
use iron_lib::*;
use std::fs::File;
use std::io::prelude::*;

fn main() {
    /*Set of region that can be specified. This allows to check values for get_region() functions
     * as well as to validate expected inputs in error messages.*/
    let regions = vec![
        "ap-northeast-1",
        "ap-northeast-2",
        "ap-south-1",
        "ap-southeast-1",
        "ap-southeast-2",
        "ca-central-1",
        "eu-central-1",
        "eu-west-1",
        "eu-west-2",
        "eu-west-3",
        "sa-east-1",
        "us-east-1",
        "us-east-2",
        "us-west-1",
        "us-west-2",
        "us-govwest-1",
        "cn-north-1",
        "cn-northwest-1",
    ];

    /*Start of program logic. This will be used to gather and parse passed arguments from the user.
     * Assesses subcommand, flags, and values passed to each.
     *
     * The use of clap autogenerated help documentation for overall run and subcommands.*/
    let app_matches = App::new("Project Ironclad Secret Store")
        //Version and authoring information
        .version("0.4.1")
        .author("Evan Conley <econmang@gmail.com>\nJacob Cromwell <cromwellj@sou.edu>")
        .about("Ironclad is a command line utility to help store and manage secret credentials through AWS.")
        //Subcommand information/flags for `list` subcommand
        //lists tables in specified region server
        .subcommand(SubCommand::with_name("list")
                    .about("List DynamoDB tables associated with a given region.")
                    .arg(Arg::with_name("region")
                         .short("r")
                         .long("region")
                         .help("Sets region to list tables from. If not set, uses default region setting.")
                         .takes_value(true)
                         .value_name("REGION")
                         ))
        //Subcommand information/flags for `put` subcommand
        //stores credential into specified table
        .subcommand(SubCommand::with_name("put")
                    .arg(Arg::with_name("identifier")
                         .required(true)
                         .help("Identifier with which to store the credential in AWS.")
                    )
                    .arg(Arg::with_name("secret")
                         .help("String to be stored at command line")
                         .required_unless("fileName")
                         )
                    .about("Store a credential through AWS.")
                    .arg(Arg::with_name("fileName")
                         .short("f")
                         .long("file")
                         .takes_value(true)
                         .value_name("FILE")
                         .required(false)
                         .help("Path to the file to be stored."))
                    .arg(Arg::with_name("table")
                         .short("t")
                         .long("table")
                         .takes_value(true)
                         .value_name("TABLE")
                         .required(false)
                         .help("Specify which table to store secret credential in.")
                         )
                    .arg(Arg::with_name("version")
                         .short("v")
                         .long("version")
                         .takes_value(true)
                         .value_name("VERSION")
                         .required(false)
                         .help("Specify the version associated with this secret.\nIf version already exists, it will be overwritten on DynamoDB.")
                         ))
        //Subcommand information/flags for `delete` subcommand
        //deletes credential from table
        .subcommand(SubCommand::with_name("delete")
                    .about("Delete specified secret from DynamoDB Table.")
                    .arg(Arg::with_name("tableName")
                         .short("t")
                         .long("table")
                         .help("Specifies name of table to find credential.")
                         .required(false)
                         .takes_value(true)
                         .value_name("TABLE")
                         )
                    .arg(Arg::with_name("identifier")
                         .required(true)
                         .help("Name of secret to be deleted from DynamoDB Table.")
                         )
                     .arg(Arg::with_name("ID")
                        .required(true)
                        .help("Number of secret to be deleted from DynamoDB Table")
                        ))
        //Subcommand information/flags for `setup` subcommand
        //creates table
        .subcommand(SubCommand::with_name("setup")
                    .about("Setup new DynamoDB Table through AWS.")
                    .arg(Arg::with_name("name")
                         .short("n")
                         .long("name")
                         .help("Indicates name of table to be setup.")
                         .required(false)
                         .takes_value(true)
                         .value_name("NAME")
                         )
                    .arg(Arg::with_name("region")
                         .short("r")
                         .long("region")
                         .help("Indicates region in which to create table.")
                         .required(false)
                         .takes_value(true)
                         .value_name("REGION")
                         )
                    )
        //Subcommand information/flags for `view` subcommand
        //Lists the identifiers of secrets in table
        .subcommand(SubCommand::with_name("view")
                    .about("View credentials in specified DynamoDB Table.")
                    .arg(Arg::with_name("table")
                         .short("t")
                         .long("table")
                         .help("Indicates a table to view other than default.")
                         .required(false)
                         .takes_value(true)
                         .value_name("TABLE")
                         ))
        //Subcommand information/flags for `getall` subcommand
        //Retrieves all secrets from a table
        .subcommand(SubCommand::with_name("getall")
                    .about("Retrieve all secret credentials from a DynamoDB Table.")
                    .arg(Arg::with_name("table")
                         .short("t")
                         .long("table")
                         .help("Indicates a table to retrieve from.")
                         .required(false)
                         .takes_value(true)
                         .value_name("TABLE")
                         ))
        //Subcommand information/flags for `get` command
        //Retrieves specified secret from table
        .subcommand(SubCommand::with_name("get")
                    .about("Retrieve a secret credential from a DynamoDB Table.")
                    .arg(Arg::with_name("identifier")
                         .help("Name of credential to be retrieved.")
                         .required(true))
                    .arg(Arg::with_name("version")
                         .help("Version number associated with item to be retreived.")
                         .required(true))
                    .arg(Arg::with_name("table")
                         .short("t")
                         .long("table")
                         .help("Indicates a table to retrieve from.")
                         .required(false)
                         .takes_value(true)
                         .value_name("TABLE")
                         ))
        //Subcommand information/flags for `delete-table` command
        //Deletes specified table from AWS
        .subcommand(SubCommand::with_name("delete-table")
                    .about("Delete specified table from AWS.")
                    .arg(Arg::with_name("tableName")
                         .help("Table to be deleted.")
                         .required(true))
                    .arg(Arg::with_name("region")
                         .short("r")
                         .long("region")
                         .help("Region of table to be deleted.")
                         .required(false)
                         .takes_value(true)
                         .value_name("REGION"))
                    )
        //Required subcommand
        .setting(AppSettings::SubcommandRequired)
        .get_matches();

    /*Program logic:
     * Uses subcommand_matches to locate which subcommand was utilized
     *      Error if none was used, or if typed incorrectly
     * After subcommand found, parses through flag/argument data
     *      Error if required arguments missing or flag used incorrectly
     * Returns specified information with helpful messages*/

    if let Some(x) = app_matches.subcommand_matches("list") {
        //Sets list subcommand arguments to specified or default values
        //Attempts to retrieve region from each
        let region = tables::get_region(x.value_of("region").unwrap_or("default"));
        match region {
            Some(reg) => {
                tables::list_tables(reg);
            } //if region correctly parsed, list tables in region
            None => {
                //else: display error informing what values can be used
                eprintln!("Error: Region not correctly specified...\n");
                let mut reg_list_string = "";
                eprintln!("Must be in list:{}", reg_list_string);
                for region in regions {
                    println!("{}", region);
                } //Region not correctly specified
            }
        }
    } else if let Some(x) = app_matches.subcommand_matches("put") {
        //Checks if filename is present to put item from file
        if x.is_present("fileName") {
            if x.is_present("secret") {
                eprintln!("ERROR: Too many arguments for storage.");
            } else {
                let mut file =
                    File::open(x.value_of("fileName").unwrap()).expect("Could not open file.");
                let mut contents = String::new();
                file.read_to_string(&mut contents)
                    .expect("Unable to read the file");

                let version = x.value_of("version").unwrap_or("1");
                let table = x.value_of("table").unwrap_or("ironclad-store");
                println!(
                    "Storing {} version {}...",
                    x.value_of("identifier").unwrap(),
                    version
                );
                secrets::put_item(
                    table,
                    x.value_of("identifier").unwrap(),
                    contents.as_str(),
                    version,
                );
            }
        } else {
            //if there exists no filename, assumed input from stdin
            let version = x.value_of("version").unwrap_or("1");
            let table = x.value_of("table").unwrap_or("ironclad-store");
            println!(
                "Storing {} version {}...",
                x.value_of("identifier").unwrap(),
                version
            );
            secrets::put_item(
                table,
                x.value_of("identifier").unwrap(),
                x.value_of("secret").unwrap(),
                version,
            );
        }
    } else if let Some(x) = app_matches.subcommand_matches("delete") {
        //Sets delete subcommand arguments to supplied values, or default if none were supplied.
        let table = x.value_of("tableName").unwrap_or("ironclad-store");
        println!(
            "Deleting {}, version number {}...",
            x.value_of("identifier").unwrap(),
            x.value_of("ID").unwrap()
        );
        secrets::delete_item(
            table,
            x.value_of("identifier").unwrap(),
            x.value_of("ID").unwrap(),
        );
    } else if let Some(x) = app_matches.subcommand_matches("setup") {
        //Sets setup arguments to supplied values, or default if none were supplied.
        let name = x.value_of("name").unwrap_or("ironclad-store");
        let region = tables::get_region(x.value_of("region").unwrap_or("default"));
        match region {
            Some(reg) => {
                tables::table_creator(reg, name);
            } //if region correctly parsed, list tables in region
            None => {
                //else: display error informing what values can be used
                eprintln!("Error: Region not correctly specified...\n");
                let mut reg_list_string = "";
                eprintln!("Must be in list:{}", reg_list_string);
                for region in regions {
                    println!("{}", region);
                }
            }
        }
    } else if let Some(x) = app_matches.subcommand_matches("view") {
        //View items in supplied table, or default table if arg not supplied
        let name = x.value_of("table").unwrap_or("ironclad-store");
        secrets::list_items(name);
    } else if let Some(x) = app_matches.subcommand_matches("getall") {
        //Get all secrets from specified table; default table if arg not supplied
        let table = x.value_of("table").unwrap_or("ironclad-store");
        println!("Retrieving secrets from {}...", table);
        secrets::get_all(table);
    } else if let Some(x) = app_matches.subcommand_matches("get") {
        //Get specified item form supplied table; default table if arg not supplied
        let table = x.value_of("table").unwrap_or("ironclad-store");
        secrets::get_item(
            table,
            x.value_of("identifier").unwrap(),
            x.value_of("version").unwrap(),
        );
    } else if let Some(x) = app_matches.subcommand_matches("delete-table") {
        //Set delete table arguments to supplied value, or default if non supplied
        //Get region from argument
        let region = tables::get_region(x.value_of("region").unwrap_or("default"));
        match region {
            Some(reg) => {
                let mut delete_table_name = x.value_of("tableName").unwrap();
                tables::table_deleter(reg, delete_table_name);
            } //if region correctly parsed, list tables in region
            None => {
                //else: display error informing what values can be used
                eprintln!("Error: Region not correctly specified...\n");
                let mut reg_list_string = "";
                eprintln!("Must be in list:{}", reg_list_string);
                for region in regions {
                    println!("{}", region);
                } //region not correclty specified
            }
        }
    }
}
