extern crate clap;
extern crate iron_lib;
extern crate rusoto_core;
extern crate rusoto_credential;
extern crate rusoto_dynamodb;
extern crate rusoto_kms;

use clap::{App, AppSettings, Arg, SubCommand};
use iron_lib::tables;
use iron_lib::tables::get_all;
use rusoto_core::region::Region;
use std::fs::File;
use std::io::prelude::*;

fn main() {
    /*Set of region that can be specified. This allows to check values for get_region() functions
     * as well as to validate expected inputs in error messages.*/
    let regions = vec![
        "ap-northeast-1",
        "ap-northeast-2",
        "ap-south-1",
        "ap-southeast-1",
        "ap-southeast-2",
        "ca-central-1",
        "eu-central-1",
        "eu-west-1",
        "eu-west-2",
        "eu-west-3",
        "sa-east-1",
        "us-east-1",
        "us-east-2",
        "us-west-1",
        "us-west-2",
        "us-govwest-1",
        "cn-north-1",
        "cn-northwest-1",
    ];

    /*Start of program logic. This will be used to gather and parse passed arguments from the user.
     * Assesses subcommand, flags, and values passed to each.
     *
     * The use of clap autogenerated help documentation for overall run and subcommands.*/
    let app_matches = App::new("Project Ironclad Secret Store")
        //Version and authoring information
        .version("0.4.1")
        .author("Evan Conley <econmang@gmail.com>\nJacob Cromwell <cromwellj@sou.edu>")
        .about("Ironclad is a command line utility to help store and manage secret credentials through AWS.")
        //Subcommand information/flags for `list` subcommand
        //lists tables in specified region server
        .subcommand(SubCommand::with_name("list")
                    .about("List DynamoDB tables associated with a given region.")
                    .arg(Arg::with_name("region")
                         .short("r")
                         .long("region")
                         .help("Sets region to list tables from. If not set, uses default region setting.")
                         .takes_value(true)
                         .value_name("REGION")
                         ))
        //Subcommand information/flags for `put` subcommand
        //stores credential into specified table
        .subcommand(SubCommand::with_name("put")
                    .arg(Arg::with_name("identifier")
                         .required(true)
                         .help("Identifier with which to store the credential in AWS.")
                    )
                    .arg(Arg::with_name("secret")
                         .help("String to be stored at command line")
                         .required_unless("fileName")
                         )
                    .about("Store a credential through AWS.")
                    .arg(Arg::with_name("fileName")
                         .short("f")
                         .long("file")
                         .takes_value(true)
                         .value_name("FILE")
                         .required(false)
                         .help("Path to the file to be stored."))
                    .arg(Arg::with_name("table")
                         .short("t")
                         .long("table")
                         .takes_value(true)
                         .value_name("TABLE")
                         .required(false)
                         .help("Specify which table to store secret credential in.")
                         )
                    .arg(Arg::with_name("version")
                         .short("v")
                         .long("version")
                         .takes_value(true)
                         .value_name("VERSION")
                         .required(false)
                         .help("Specify the version associated with this secret.\nIf version already exists, it will be overwritten on DynamoDB.")
                         ))
        //Subcommand information/flags for `delete` subcommand
        //deletes credential from table
        .subcommand(SubCommand::with_name("delete")
                    .about("Delete specified secret from DynamoDB Table.")
                    .arg(Arg::with_name("tableName")
                         .short("t")
                         .long("table")
                         .help("Specifies name of table to find credential.")
                         .required(false)
                         .takes_value(true)
                         .value_name("TABLE")
                         )
                    .arg(Arg::with_name("identifier")
                         .required(true)
                         .help("Name of secret to be deleted from DynamoDB Table.")
                         )
                     .arg(Arg::with_name("ID")
                        .required(true)
                        .help("Number of secret to be deleted from DynamoDB Table")
                        ))
        //Subcommand information/flags for `setup` subcommand
        //creates table
        .subcommand(SubCommand::with_name("setup")
                    .about("Setup new DynamoDB Table through AWS.")
                    .arg(Arg::with_name("name")
                         .short("n")
                         .long("name")
                         .help("Indicates name of table to be setup.")
                         .required(false)
                         .takes_value(true)
                         .value_name("NAME")
                         )
                    .arg(Arg::with_name("region")
                         .short("r")
                         .long("region")
                         .help("Indicates region in which to create table.")
                         .required(false)
                         .takes_value(true)
                         .value_name("REGION")
                         )
                    )
        //Subcommand information/flags for `view` subcommand
        //Lists the identifiers of secrets in table
        .subcommand(SubCommand::with_name("view")
                    .about("View credentials in specified DynamoDB Table.")
                    .arg(Arg::with_name("table")
                         .short("t")
                         .long("table")
                         .help("Indicates a table to view other than default.")
                         .required(false)
                         .takes_value(true)
                         .value_name("TABLE")
                         ))
        //Subcommand information/flags for `getall` subcommand
        //Retrieves all secrets from a table
        .subcommand(SubCommand::with_name("getall")
                    .about("Retrieve all secret credentials from a DynamoDB Table.")
                    .arg(Arg::with_name("table")
                         .short("t")
                         .long("table")
                         .help("Indicates a table to retrieve from.")
                         .required(false)
                         .takes_value(true)
                         .value_name("TABLE")
                         ))
        //Subcommand information/flags for `get` command
        //Retrieves specified secret from table
        .subcommand(SubCommand::with_name("get")
                    .about("Retrieve a secret credential from a DynamoDB Table.")
                    .arg(Arg::with_name("identifier")
                         .help("Name of credential to be retrieved.")
                         .required(true))
                    .arg(Arg::with_name("version")
                         .help("Version number associated with item to be retreived.")
                         .required(true))
                    .arg(Arg::with_name("table")
                         .short("t")
                         .long("table")
                         .help("Indicates a table to retrieve from.")
                         .required(false)
                         .takes_value(true)
                         .value_name("TABLE")
                         ))
        //Subcommand information/flags for `delete-table` command
        //Deletes specified table from AWS
        .subcommand(SubCommand::with_name("delete-table")
                    .about("Delete specified table from AWS.")
                    .arg(Arg::with_name("tableName")
                         .help("Table to be deleted.")
                         .required(true))
                    .arg(Arg::with_name("region")
                         .short("r")
                         .long("region")
                         .help("Region of table to be deleted.")
                         .required(false)
                         .takes_value(true)
                         .value_name("REGION"))
                    )
        //Required subcommand
        .setting(AppSettings::SubcommandRequired)
        .get_matches();

    /*Program logic:
     * Uses subcommand_matches to locate which subcommand was utilized
     *      Error if none was used, or if typed incorrectly
     * After subcommand found, parses through flag/argument data
     *      Error if required arguments missing or flag used incorrectly
     * Returns specified information with helpful messages*/

    if let Some(x) = app_matches.subcommand_matches("list") {
        let region = tables::get_region(x.value_of("region").unwrap_or("default"));
            match region {
                Some(reg) => {
                    tables::list_tables(reg);
                } //if region correctly parsed, list tables in region
                None => {
                    //else: display error informing what values can be used
                    eprintln!("Error: Region not correctly specified...\n");
                    let mut reg_list_string = "";
                    eprintln!("Must be in list:{}", reg_list_string);
                    for region in regions {
                        println!("{}", region);
                    }
                }
            }
    } else if let Some(x) = app_matches.subcommand_matches("put") {
        {
            if x.is_present("fileName") {
                if x.is_present("secret") {
                    eprintln!("ERROR: Too many arguments for storage.");
                } else {
                    let mut file =
                        File::open(x.value_of("fileName").unwrap()).expect("Could not open file.");
                    let mut contents = String::new();
                    file.read_to_string(&mut contents)
                        .expect("Unable to read the file");

                    if x.is_present("version") && x.is_present("table") {
                        println!(
                            "Storing file: {:?} version {} with identifier {:?} in table: {:?}",
                            x.value_of("fileName").unwrap(),
                            x.value_of("version").unwrap(),
                            x.value_of("identifier").unwrap(),
                            x.value_of("table").unwrap()
                        );
                        tables::put_item(
                            x.value_of("table").unwrap(),
                            x.value_of("identifier").unwrap(),
                            contents.as_str(),
                            x.value_of("version").unwrap(),
                        );
                    } else if x.is_present("version") {
                        println!(
                            "Storing file: {:?} version {} with identifier {:?} in default table",
                            x.value_of("fileName").unwrap(),
                            x.value_of("version").unwrap(),
                            x.value_of("identifier").unwrap()
                        );
                        tables::put_item(
                            "ironclad-store",
                            x.value_of("identifier").unwrap(),
                            contents.as_str(),
                            x.value_of("version").unwrap(),
                        );
                    } else if x.is_present("table") {
                        println!(
                            "Storing file: {:?} with identifer {:?} in table: {:?}",
                            x.value_of("fileName").unwrap(),
                            x.value_of("idenitifier").unwrap(),
                            x.value_of("table").unwrap()
                        );
                        tables::put_item(
                            x.value_of("table").unwrap(),
                            x.value_of("identifier").unwrap(),
                            contents.as_str(),
                            "1",
                        );
                    } else {
                        println!(
                            "Storing file: {:?} with idenitifier {:?} in default table",
                            x.value_of("fileName").unwrap(),
                            x.value_of("identifier").unwrap()
                        );
                        tables::put_item(
                            "ironclad-store",
                            x.value_of("identifier").unwrap(),
                            contents.as_str(),
                            "1",
                        );
                    }
                }
            } else if x.is_present("table") {
                if x.is_present("version") {
                    println!(
                        "Storing secret {:?} version {} in table: {:?}",
                        x.value_of("identifier").unwrap(),
                        x.value_of("version").unwrap(),
                        x.value_of("table").unwrap()
                    );
                    tables::put_item(
                        x.value_of("table").unwrap(),
                        x.value_of("identifier").unwrap(),
                        x.value_of("secret").unwrap(),
                        x.value_of("version").unwrap(),
                    );
                } else {
                    println!(
                        "Storing secret {:?} in table: {:?}",
                        x.value_of("identifier").unwrap(),
                        x.value_of("table").unwrap()
                    );
                    tables::put_item(
                        x.value_of("table").unwrap(),
                        x.value_of("identifier").unwrap(),
                        x.value_of("secret").unwrap(),
                        "1",
                    );
                }
            } else {
                if x.is_present("version") {
                    println!(
                        "Storing {:?} version {} in default table",
                        x.value_of("identifier").unwrap(),
                        x.value_of("version").unwrap()
                    );
                    tables::put_item(
                        "ironclad-store",
                        x.value_of("identifier").unwrap(),
                        x.value_of("secret").unwrap(),
                        x.value_of("version").unwrap(),
                    );
                } else {
                    println!(
                        "Storing {:?} in default table",
                        x.value_of("identifier").unwrap()
                    );
                    tables::put_item(
                        "ironclad-store",
                        x.value_of("identifier").unwrap(),
                        x.value_of("secret").unwrap(),
                        "1",
                    );
                }
            }
        }
    } else if let Some(x) = app_matches.subcommand_matches("delete") {
        if x.is_present("tableName") && x.is_present("identifier") && x.is_present("ID") {
            println!(
                "Deleteting {:?}, version number {:?} from table {:?}.",
                x.value_of("identifier").unwrap(),
                x.value_of("ID").unwrap(),
                x.value_of("tableName").unwrap()
            );
            tables::delete_item(
                x.value_of("tableName").unwrap(),
                x.value_of("identifier").unwrap(),
                x.value_of("ID").unwrap(),
            )
        } else {
            println!(
                "Deleting {:?}, version number {:?} from default table.",
                x.value_of("identifier").unwrap(),
                x.value_of("ID").unwrap()
            );
            tables::delete_item(
                "ironclad-store",
                x.value_of("identifier").unwrap(),
                x.value_of("ID").unwrap(),
            );
        }
    } else if let Some(x) = app_matches.subcommand_matches("setup") {
        let name = x.value_of("name").unwrap_or("ironclad-store"); 
        let region = tables::get_region(x.value_of("region").unwrap_or("default"));
        match region {
                Some(reg) => {
                    tables::table_creator(reg,name);
                } //if region correctly parsed, list tables in region
                None => {
                    //else: display error informing what values can be used
                    eprintln!("Error: Region not correctly specified...\n");
                    let mut reg_list_string = "";
                    eprintln!("Must be in list:{}", reg_list_string);
                    for region in regions {
                        println!("{}", region);
                    }
                }
            }
    } else if let Some(x) = app_matches.subcommand_matches("view") {
        let name = x.value_of("table").unwrap_or("ironclad-store");
        tables::list_items(name);
    } else if let Some(x) = app_matches.subcommand_matches("getall") {
        if x.is_present("table") {
            println!(
                "I'd be attempting to retrieve all secrets from: {:?}",
                x.value_of("table").unwrap()
            );
            get_all(x.value_of("table").unwrap());
        } else {
            println!("I'd be attempting to retrieve all secrets from default table.");
            get_all("ironclad-store");
        }
    } else if let Some(x) = app_matches.subcommand_matches("get") {
        if x.is_present("table") {
            println!(
                "I'd be attempting to retrieve {:?} from: {:?}",
                x.value_of("identifier").unwrap(),
                x.value_of("table").unwrap()
            );
        } else {
            tables::get_item(
                "ironclad-store",
                x.value_of("identifier").unwrap(),
                x.value_of("version").unwrap(),
            );
        }
    } else if let Some(x) = app_matches.subcommand_matches("delete-table") {
        let region = tables::get_region(x.value_of("region").unwrap_or("default"));
            match region {
                Some(reg) => {
                    let mut delete_table_name = x.value_of("tableName").unwrap();
                    tables::table_deleter(reg, delete_table_name);
                } //if region correctly parsed, list tables in region
                None => {
                    //else: display error informing what values can be used
                    eprintln!("Error: Region not correctly specified...\n");
                    let mut reg_list_string = "";
                    eprintln!("Must be in list:{}", reg_list_string);
                    for region in regions {
                        println!("{}", region);
                    }
                }
            }
            let mut delete_table_name = x.value_of("tableName").unwrap();
            tables::table_deleter(Region::default(), delete_table_name);
    }
}
